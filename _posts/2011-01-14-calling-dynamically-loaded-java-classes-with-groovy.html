---
layout: post
status: publish
published: true
title: Calling dynamically loaded Java classes with Groovy
author:
  display_name: Rob Petti
  login: rpetti
  email: rob.petti@gmail.com
  url: http://www.robpetti.com
author_login: rpetti
author_email: rob.petti@gmail.com
author_url: http://www.robpetti.com
excerpt: "So I've got this ridiculous task ahead of me... I somehow need to call a
  Spring Bean data access object (DAO) from InstallAnywhere using groovy scripting.
  The idea is that the webapp being installed has all the code in order to set up
  the database, but there are certain things that need to be done by the installer.
  Part of getting this working is dynamically loading jars from a directory, and using
  reflection to grab the class and method I need to call...\r\n"
wordpress_id: 41
wordpress_url: http://robpetti.com/?p=41
date: '2011-01-14 00:35:37 -0700'
date_gmt: '2011-01-14 05:35:37 -0700'
categories:
- Java
tags: []
comments:
- id: 2
  author: Simon
  author_email: stimms@gmail.com
  author_url: ''
  date: '2011-02-08 16:33:38 -0700'
  date_gmt: '2011-02-08 21:33:38 -0700'
  content: That is a really good use of the groovy plugin.
- id: 3
  author: Rob Petti
  author_email: rob.petti@gmail.com
  author_url: http://www.robpetti.com
  date: '2011-02-08 16:42:17 -0700'
  date_gmt: '2011-02-08 21:42:17 -0700'
  content: Thanks, but it's a shame it didn't exactly work the way I expected it.
    IA had conflicting classes in it's top-level ClassLoader that were causing all
    sorts of issues with the code I was trying to execute. In the end I had to spawn
    a new instance of the JVM in order to get it to run correctly. Still a nifty trick
    that I will likely use later, though. :)
---
<p>So I've got this ridiculous task ahead of me... I somehow need to call a Spring Bean data access object (DAO) from InstallAnywhere using groovy scripting. The idea is that the webapp being installed has all the code in order to set up the database, but there are certain things that need to be done by the installer. Part of getting this working is dynamically loading jars from a directory, and using reflection to grab the class and method I need to call...<br />
<a id="more"></a><a id="more-41"></a><br />
Instead of duplicating code and having to maintain it in multiple places, I asked the dev team to provide me a singular class member function that I can call externally. Needless to say, they failed to deliver, and blindly pointed me towards the spring DAOs they were using to access the database. This requires a whole bunch of additional setup in order to get working, since it was written to work in the webapp context.</p>
<p>I wrote a simple class to wrap all that stuff away for me (it's not working quite yet, but I'm hopeful that we can get the problems worked out,) and now I need to integrate it with the installer. There are two basic approaches here. One is to build an IA plugin that will link in the code directly. The problem here is that I don't want to be building installing plugins on the fly during the build, especially when other installer builds need to use that IA instance. So that idea is out.</p>
<p>The alternative is to package the jar and it's dependencies in the installer, and extract them when needed. IA comes with a nifty (and until now, unknown to me) plugin that allows you to extract files from the installer during the pre-installation phase. So how do I run it?</p>
<p>You can always add a main class, of course, but I'm far more masochistic than that. We have a simple plugin that runs a groovy script provided as a variable, so I figured that's the best way to go. If you don't have such a plugin, I highly recommend writing something like it. I can't provide ours, but it shouldn't be too difficult to quickly throw together.</p>
<pre class="brush: groovy" >
def classLoader;</p>
<p>def loadJars(jarPath) {<br />
	def topClassLoader = ClassLoader.systemClassLoader;<br />
	while(topClassLoader.parent){<br />
		topClassLoader = topClassLoader.parent;<br />
	}</p>
<p>	&#47;&#47;this is a hack in order to get the system classloader updated<br />
	&#47;&#47;in the event that your java code tries to use it for it's own reflection<br />
	&#47;&#47;routines. Might not work for all JREs.<br />
	def addURL = URLClassLoader.class.getDeclaredMethod("addURL", [URL.class] as Class[]);<br />
	addURL.setAccessible(true);<br />
	ClassLoader cl = ClassLoader.getSystemClassLoader();</p>
<p>	def jarList = [];<br />
	def libDir = new File(jarPath);<br />
	libDir.eachFileMatch(~".*jar"){f -><br />
		jarList.add(f.toURL());<br />
		addURL.invoke(cl, [f.toURL()] as URL[]);<br />
	}<br />
	classLoader = new URLClassLoader(jarList as URL[], topClassLoader);<br />
}</p>
<p>def getMethod() {<br />
	def api = Class.forName("com.corp.ClassOfInterest", true, classLoader);<br />
	def updateMethod = api.getMethod("methodOfInterest", [java.lang.String.class, java.lang.String.class, java.lang.String.class] as Class[]);<br />
	return updateMethod;<br />
}</p>
<p>def executeMethod(arg1, arg2, arg3) {<br />
	def methodOfInterest = getMethod();<br />
	methodOfInterest.invoke(null,<br />
		[	new String(arg1),<br />
			new String(arg2),<br />
			new String(arg3)<br />
		] as Object[]);<br />
}</p>
<p>loadJars(this.args[0]);<br />
executeMethod(this.args[2], this.args[3], this.args[1]);<br />
<&#47;pre></p>
<p>In my case, the script above was written to be executed either from the command line, or with groovy's <code>run()<&#47;code> function. It creates a classloader with all the jar files in the directory given in the first argument, and uses reflection to locate a static function in a class. You could get a member function of course, but I didn't have a need for any object instances.</p>
<p>Provided the function you are trying to call actually works, there should be no problem... hopefully. XD</p>
